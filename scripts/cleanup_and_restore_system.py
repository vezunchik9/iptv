#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
–°–∏—Å—Ç–µ–º–∞ –æ—á–∏—Å—Ç–∫–∏ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è IPTV –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤
–£–¥–∞–ª—è–µ—Ç –Ω–µ—Ä–∞–±–æ—á–∏–µ –∫–∞–Ω–∞–ª—ã –∏ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∏—Ö –∏–∑ –¥–æ–Ω–æ—Ä—Å–∫–∏—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
"""

import asyncio
import os
import json
import logging
from datetime import datetime
import sys

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ —Å–∫—Ä–∏–ø—Ç–∞–º
sys.path.insert(0, os.path.dirname(__file__))

from real_video_checker import RealVideoChecker
from smart_playlist_parser import SmartPlaylistParser

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class CleanupAndRestoreSystem:
    def __init__(self, config_file='donors_config.json'):
        self.config_file = config_file
        self.video_checker = RealVideoChecker(
            timeout=30,
            max_concurrent=3,
            test_duration=8,
            buffer_threshold=3
        )
        self.smart_parser = SmartPlaylistParser(config_file)
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.stats = {
            'total_checked': 0,
            'total_removed': 0,
            'total_restored': 0,
            'categories_processed': 0,
            'processing_time': 0
        }
    
    async def cleanup_single_category(self, category_file):
        """–û—á–∏—â–∞–µ—Ç –æ–¥–Ω—É –∫–∞—Ç–µ–≥–æ—Ä–∏—é –æ—Ç –Ω–µ—Ä–∞–±–æ—á–∏—Ö –∫–∞–Ω–∞–ª–æ–≤"""
        logger.info(f"üßπ –û—á–∏—â–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é: {category_file}")
        
        if not os.path.exists(category_file):
            logger.warning(f"–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {category_file}")
            return None
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –æ—á–∏—â–∞–µ–º
        report = await self.video_checker.check_playlist_and_cleanup(category_file)
        
        if 'error' in report:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ {category_file}: {report['error']}")
            return None
        
        logger.info(f"‚úÖ –ö–∞—Ç–µ–≥–æ—Ä–∏—è –æ—á–∏—â–µ–Ω–∞: {report['working_channels']}/{report['total_channels']} –∫–∞–Ω–∞–ª–æ–≤ –æ—Å—Ç–∞–ª–æ—Å—å")
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        self.stats['total_checked'] += report['total_channels']
        self.stats['total_removed'] += report['broken_channels']
        self.stats['categories_processed'] += 1
        
        return report
    
    async def restore_from_donors(self, category_name):
        """–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∫–∞–Ω–∞–ª—ã –∏–∑ –¥–æ–Ω–æ—Ä—Å–∫–∏—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤"""
        logger.info(f"üîÑ –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–∞–Ω–∞–ª—ã –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: {category_name}")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º —É–º–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        try:
            # –í—Ä–µ–º–µ–Ω–Ω–æ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            original_mapping = self.smart_parser.config.get('category_mapping', {})
            
            if category_name in original_mapping:
                # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Ç–æ–ª—å–∫–æ –¥–ª—è —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
                temp_mapping = {category_name: original_mapping[category_name]}
                self.smart_parser.config['category_mapping'] = temp_mapping
                
                # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–∞—Ä—Å–∏–Ω–≥
                donors = self.smart_parser.config.get('donors', {})
                restored_count = 0
                
                for donor_name, donor_config in donors.items():
                    if donor_config.get('enabled', True):
                        logger.info(f"–ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ–Ω–æ—Ä–∞ {donor_name} –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è...")
                        
                        # –°–∫–∞—á–∏–≤–∞–µ–º –ø–ª–µ–π–ª–∏—Å—Ç –¥–æ–Ω–æ—Ä–∞
                        content = self.smart_parser.download_playlist(donor_config['url'])
                        if content:
                            # –ü–∞—Ä—Å–∏–º –∫–∞–Ω–∞–ª—ã
                            channels = self.smart_parser.parse_m3u_playlist(content)
                            
                            # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –∫–∞–Ω–∞–ª—ã
                            for channel in channels:
                                category = self.smart_parser.categorize_channel(channel)
                                if category == category_name:
                                    added = self.smart_parser.add_or_update_channel(channel, category)
                                    if added:
                                        restored_count += 1
                
                # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
                self.smart_parser.config['category_mapping'] = original_mapping
                
                logger.info(f"‚úÖ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –∫–∞–Ω–∞–ª–æ–≤: {restored_count}")
                self.stats['total_restored'] += restored_count
                
                return restored_count
            else:
                logger.warning(f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è {category_name} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏")
                return 0
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category_name}: {e}")
            return 0
    
    async def process_all_categories(self, categories_dir='categories'):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Å–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: –æ—á–∏—Å—Ç–∫–∞ + –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ"""
        start_time = datetime.now()
        logger.info("üöÄ –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ–ª–Ω—É—é –æ—á–∏—Å—Ç–∫—É –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π")
        
        if not os.path.exists(categories_dir):
            logger.error(f"–ü–∞–ø–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {categories_dir}")
            return
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
        category_files = []
        for file in os.listdir(categories_dir):
            if file.endswith('.m3u') and not file.startswith('.'):
                category_files.append(os.path.join(categories_dir, file))
        
        if not category_files:
            logger.warning("–ù–µ –Ω–∞–π–¥–µ–Ω–æ —Ñ–∞–π–ª–æ–≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏")
            return
        
        logger.info(f"–ù–∞–π–¥–µ–Ω–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏: {len(category_files)}")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é
        cleanup_reports = []
        
        for category_file in category_files:
            try:
                # –û—á–∏—â–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é
                cleanup_report = await self.cleanup_single_category(category_file)
                
                if cleanup_report:
                    cleanup_reports.append(cleanup_report)
                    
                    # –ï—Å–ª–∏ —É–¥–∞–ª–∏–ª–∏ –º–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–æ–≤, –ø—ã—Ç–∞–µ–º—Å—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å
                    if cleanup_report['broken_channels'] > 0:
                        category_name = os.path.basename(category_file).replace('.m3u', '')
                        await self.restore_from_donors(category_name)
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ {category_file}: {e}")
                continue
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
        self.smart_parser.update_category_headers()
        
        # –í—ã—á–∏—Å–ª—è–µ–º –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        self.stats['processing_time'] = (datetime.now() - start_time).total_seconds()
        
        # –°–æ–∑–¥–∞–µ–º –æ—Ç—á–µ—Ç
        await self.create_cleanup_report(cleanup_reports)
        
        logger.info("üéâ –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
    
    async def create_cleanup_report(self, cleanup_reports):
        """–°–æ–∑–¥–∞–µ—Ç –¥–µ—Ç–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ –æ—á–∏—Å—Ç–∫–µ"""
        report_file = f"reports/cleanup_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        # –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É –¥–ª—è –æ—Ç—á–µ—Ç–æ–≤
        os.makedirs("reports", exist_ok=True)
        
        report_data = {
            'timestamp': datetime.now().isoformat(),
            'summary': {
                'categories_processed': self.stats['categories_processed'],
                'total_channels_checked': self.stats['total_checked'],
                'total_channels_removed': self.stats['total_removed'],
                'total_channels_restored': self.stats['total_restored'],
                'processing_time_seconds': self.stats['processing_time'],
                'cleanup_efficiency': (self.stats['total_removed'] / self.stats['total_checked'] * 100) if self.stats['total_checked'] > 0 else 0,
                'restore_efficiency': (self.stats['total_restored'] / self.stats['total_removed'] * 100) if self.stats['total_removed'] > 0 else 0
            },
            'category_details': []
        }
        
        # –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ç–∞–ª–∏ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
        for report in cleanup_reports:
            category_detail = {
                'category': os.path.basename(report['playlist_file']).replace('.m3u', ''),
                'total_channels': report['total_channels'],
                'working_channels': report['working_channels'],
                'removed_channels': report['broken_channels'],
                'cleanup_percentage': report['cleanup_percentage'],
                'backup_file': report['backup_file'],
                'broken_channels_list': report['broken_list'][:5]  # –ü–µ—Ä–≤—ã–µ 5 –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏
            }
            report_data['category_details'].append(category_detail)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç—á–µ—Ç
        try:
            with open(report_file, 'w', encoding='utf-8') as f:
                json.dump(report_data, f, ensure_ascii=False, indent=2)
            
            logger.info(f"üìä –û—Ç—á–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {report_file}")
            
            # –í—ã–≤–æ–¥–∏–º –∫—Ä–∞—Ç–∫—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –≤ –∫–æ–Ω—Å–æ–ª—å
            self.print_summary_stats(report_data)
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ—Ç—á–µ—Ç–∞: {e}")
    
    def print_summary_stats(self, report_data):
        """–í—ã–≤–æ–¥–∏—Ç –∫—Ä–∞—Ç–∫—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –≤ –∫–æ–Ω—Å–æ–ª—å"""
        summary = report_data['summary']
        
        print("\n" + "="*70)
        print("üìä –ò–¢–û–ì–û–í–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê –û–ß–ò–°–¢–ö–ò –ò –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ò–Ø")
        print("="*70)
        print(f"üóÇÔ∏è  –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–π: {summary['categories_processed']}")
        print(f"üîç –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ –∫–∞–Ω–∞–ª–æ–≤: {summary['total_channels_checked']}")
        print(f"‚ùå –£–¥–∞–ª–µ–Ω–æ –Ω–µ—Ä–∞–±–æ—á–∏—Ö: {summary['total_channels_removed']}")
        print(f"‚úÖ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –Ω–æ–≤—ã—Ö: {summary['total_channels_restored']}")
        print(f"‚è±Ô∏è  –í—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏: {summary['processing_time_seconds']:.1f} —Å–µ–∫")
        print(f"üßπ –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –æ—á–∏—Å—Ç–∫–∏: {summary['cleanup_efficiency']:.1f}%")
        print(f"üîÑ –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è: {summary['restore_efficiency']:.1f}%")
        
        if report_data['category_details']:
            print(f"\nüìÅ –î–ï–¢–ê–õ–ò –ü–û –ö–ê–¢–ï–ì–û–†–ò–Ø–ú:")
            for detail in report_data['category_details']:
                if detail['removed_channels'] > 0:
                    print(f"   {detail['category']}: -{detail['removed_channels']} –∫–∞–Ω–∞–ª–æ–≤ ({detail['cleanup_percentage']:.1f}%)")
        
        print("="*70)
    
    async def smart_cleanup_mode(self, min_channels_threshold=5):
        """–£–º–Ω—ã–π —Ä–µ–∂–∏–º –æ—á–∏—Å—Ç–∫–∏ - –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏"""
        logger.info("üß† –ó–∞–ø—É—Å–∫–∞–µ–º —É–º–Ω—ã–π —Ä–µ–∂–∏–º –æ—á–∏—Å—Ç–∫–∏")
        
        categories_dir = 'categories'
        if not os.path.exists(categories_dir):
            logger.error(f"–ü–∞–ø–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {categories_dir}")
            return
        
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –≤—ã–±–∏—Ä–∞–µ–º –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏
        candidates = []
        
        for file in os.listdir(categories_dir):
            if file.endswith('.m3u') and not file.startswith('.'):
                category_file = os.path.join(categories_dir, file)
                
                try:
                    # –°—á–∏—Ç–∞–µ–º –∫–∞–Ω–∞–ª—ã –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
                    with open(category_file, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    channel_count = len([line for line in content.splitlines() 
                                       if line.strip() and not line.startswith('#')])
                    
                    # –ï—Å–ª–∏ –∫–∞–Ω–∞–ª–æ–≤ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
                    if channel_count >= min_channels_threshold:
                        candidates.append({
                            'file': category_file,
                            'name': file.replace('.m3u', ''),
                            'channel_count': channel_count
                        })
                
                except Exception as e:
                    logger.debug(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ {category_file}: {e}")
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –∫–∞–Ω–∞–ª–æ–≤ (—Å–Ω–∞—á–∞–ª–∞ –±–æ–ª—å—à–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏)
        candidates.sort(key=lambda x: x['channel_count'], reverse=True)
        
        logger.info(f"–í—ã–±—Ä–∞–Ω–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è —É–º–Ω–æ–π –æ—á–∏—Å—Ç–∫–∏: {len(candidates)}")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        for candidate in candidates:
            logger.info(f"üéØ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º: {candidate['name']} ({candidate['channel_count']} –∫–∞–Ω–∞–ª–æ–≤)")
            
            # –û—á–∏—â–∞–µ–º
            cleanup_report = await self.cleanup_single_category(candidate['file'])
            
            if cleanup_report and cleanup_report['broken_channels'] > 0:
                # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –µ—Å–ª–∏ –µ—Å—Ç—å —á—Ç–æ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å
                await self.restore_from_donors(candidate['name'])

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='–°–∏—Å—Ç–µ–º–∞ –æ—á–∏—Å—Ç–∫–∏ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è IPTV –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤')
    parser.add_argument('--mode', choices=['full', 'smart', 'category'], default='smart',
                       help='–†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã: full (–≤—Å–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏), smart (—Ç–æ–ª—å–∫–æ –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ), category (–æ–¥–Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—è)')
    parser.add_argument('--category', help='–ò–º—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è —Ä–µ–∂–∏–º–∞ category')
    parser.add_argument('--config', default='donors_config.json', help='–§–∞–π–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏')
    parser.add_argument('--min-channels', type=int, default=5, help='–ú–∏–Ω–∏–º—É–º –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏')
    
    args = parser.parse_args()
    
    async def run_cleanup():
        system = CleanupAndRestoreSystem(args.config)
        
        if args.mode == 'full':
            await system.process_all_categories()
        elif args.mode == 'smart':
            await system.smart_cleanup_mode(args.min_channels)
        elif args.mode == 'category':
            if not args.category:
                print("‚ùå –î–ª—è —Ä–µ–∂–∏–º–∞ 'category' —É–∫–∞–∂–∏—Ç–µ --category")
                return
            
            category_file = f"categories/{args.category}.m3u"
            cleanup_report = await system.cleanup_single_category(category_file)
            
            if cleanup_report and cleanup_report['broken_channels'] > 0:
                await system.restore_from_donors(args.category)
    
    asyncio.run(run_cleanup())

if __name__ == "__main__":
    main()
